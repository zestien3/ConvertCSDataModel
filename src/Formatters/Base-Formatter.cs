using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;

namespace Z3
{
    internal abstract class BaseFormatter
    {
        public static readonly List<string> csStandardTypes = new() { "void", "bool", "sbyte", "byte", "char",
                                                                      "int16", "uint16", "int32", "uint32",
                                                                      "int64", "uint64", "single", "double",
                                                                      "string", "typedReference", "IntPtr", "UIntPtr",
                                                                      "object", "System.DateTime", "System.DateOnly" };

        protected TextWriter Output { get; }

        protected MetadataAssemblyInfo AssemblyInfo { get; }

        protected List<string> Usings { get; }

        protected int IndentLength { get; set; }

        /// <summary>
        /// The constructor of the abstract base class <see cref="BaseFormatter"/>.
        /// </summary>
        /// <param name="assemblyInfo">The assembly for which we create the output.</param>
        /// <param name="output">The output to which the type script code must be written.</param>
        protected BaseFormatter(MetadataAssemblyInfo assemblyInfo, TextWriter output)
        {
            Output = output;
            AssemblyInfo = assemblyInfo;
            Usings = [];
            IndentLength = 4;
        }

        /// <summary>
        /// Write the class representation formatted to the required programming language.
        /// </summary>
        /// <remarks>
        /// There are a whole number of methods called to write a source file representing the given class.
        /// If you think that there is a class missing for a new programming language that you want to add,
        /// please feel free to add it.
        /// </remarks>
        /// <param name="classInfo">The class for which the definition is to be written.</param>
        public void FormatClass(MetadataClassInfo classInfo)
        {
            // Start by writing a mulitline comment stating that the file is autogenerated.
            var assemblyName = Path.GetFileNameWithoutExtension(Assembly.GetEntryAssembly()!.ManifestModule.Name);
            WriteMultilineComment([
                $"This file is generated by {assemblyName} (https://github.com/zestien3/ConvertCSDataModel)",
                "Any changes made to this file will be lost once the file is re-generated.",
                $"The information in this file is collected from the .NET class {classInfo.FullName}"
            ], 0);
            Output.WriteLine();

            // Write a fileheader if the target language requires one.
            WriteFileHeader(classInfo);

            // If we need to reference a file for externally defined classes, this can be done here.
            // The first one is for the baseclass of the class we are processing.
            // Interfaces are not yet supported. 
            if (null != classInfo.BaseType)
            {
                var type = csStandardTypes.Contains(classInfo.BaseType.Name!) ? classInfo.BaseTypeFullName! : classInfo.BaseType.Name!;
                if (!Usings.Contains(type))
                {
                    Usings.Add(type);
                    WriteFileReference(classInfo.BaseType.FullName, classInfo.SubFolder);
                }
            }

            // Here we write the references to the files for the defined properties.
            foreach (var property in classInfo.Properties.Values)
            {
                var type = FormatType(property);
                if (!Usings.Contains(type) && !property.DontSerialize && !property.IsStandardType)
                {
                    Usings.Add(type);
                    WriteFileReference(property.ReferencedType!, property.DefiningClass.SubFolder);
                }
            }

            // Here we write the references to the files for the defined fields.
            foreach (var field in classInfo.Fields.Values)
            {
                var type = FormatType(field);
                if (!Usings.Contains(type) && !field.DontSerialize && !field.IsStandardType)
                {
                    Usings.Add(type);
                    WriteFileReference(field.ReferencedType!, field.DefiningClass.SubFolder);
                }
            }

            Output.WriteLine();

            // Here we can write the namespace the class is defined in.
            OpenNamespace(classInfo);

            // Now we write the XML documentation of the class
            // and the statement that starts the class definition.
            WriteXmlDocumentation(classInfo.XmlComment, 0);
            OpenClass(classInfo);

            // Here we can add a constructor if we want.
            WriteConstructor(classInfo);

            // Now we write the definitions of all properties that are to be serialized.
            foreach (var property in classInfo.Properties.Values)
            {
                if (!property.DontSerialize)
                {
                    Output.WriteLine();
                    WriteXmlDocumentation(property.XmlComment, 1);
                    WriteProperty(property);
                }
            }

            // Followed by the definitions of all fields that are to be serialized.
            foreach (var field in classInfo.Fields.Values)
            {
                // Also skip backing fields.
                if (!field.Name!.StartsWith('<') && !field.DontSerialize)
                {
                    Output.WriteLine();
                    WriteXmlDocumentation(field.XmlComment, 1);
                    WriteField(field);
                }
            }

            // We now have the chance to close the class.
            CloseClass(classInfo);

            // We now have the chance to close the namespace.
            CloseNamespace(classInfo);
        }

        protected abstract void WriteComment(string str, int indentLevel);
        protected abstract void WriteMultilineComment(IEnumerable<string> str, int indentLevel);
        protected abstract void WriteXmlDocumentation(XmlDocumentation? documentation, int indentLevel);
        protected abstract void WriteFileHeader(MetadataClassInfo classInfo);
        protected abstract void WriteFileReference(string className, string currentSubFolder);
        protected abstract void OpenNamespace(MetadataClassInfo classInfo);
        protected abstract void OpenClass(MetadataClassInfo classInfo);
        protected abstract void WriteConstructor(MetadataClassInfo classInfo);
        protected abstract void WriteProperty(MetadataPropertyInfo classInfo);
        protected abstract void WriteField(MetadataFieldInfo classInfo);
        protected abstract void CloseClass(MetadataClassInfo classInfo);
        protected abstract void CloseNamespace(MetadataClassInfo classInfo);
        protected abstract string ToStandardType(int index);

        /// <summary>
        /// Gets the string represengtation of the basic type of the given member.
        /// It is stripped from the namespace and the
        /// </summary>
        /// <param name="memberInfo">The property or field to get the basic type from.</param>
        /// <returns>A string representing the basic type of the property or field.</returns>
        protected string FormatType(IMemberInfo memberInfo)
        {
            if (string.IsNullOrEmpty(memberInfo.ReferencedType))
            {
                return string.Empty;
            }

            if (memberInfo.IsStandardType)
            {
                return ToStandardType(BaseFormatter.csStandardTypes.IndexOf(memberInfo.ReferencedType!));
            }

            // Remove the namespace
            if (memberInfo.ReferencedType!.Contains('.'))
            {
                return memberInfo.ReferencedType.Substring(memberInfo.ReferencedType.LastIndexOf('.') + 1);
            }

            return memberInfo.ReferencedType;
        }

        protected void WriteIndent(int level)
        {
            Output.Write(new string(' ', IndentLength * level));
        }

        /// <summary>
        /// Convert the CamelCased string into a list of small strings,
        /// each one starting from an uppercase letter.
        /// The casing itself is not changed.
        /// </summary>
        /// <remarks>
        /// Since the strings are pretty short, we will not use a StringBuilder.
        /// </remarks>
        /// <param name="s">The CamelCased string to split.</param>
        /// <returns>A list of string making up the CamelCased string</returns>
        protected static List<string> SplitCamelCasing(string s)
        {
            var result = new List<string>();
            var stringPart = new string(s[0], 1);
            bool startOfStringPart = true;
            for (int i = 1; i < s.Length; i++)
            {
                startOfStringPart = startOfStringPart && char.IsAsciiLetterUpper(s[i]);
                if (char.IsAsciiLetterUpper(s[i]) && !startOfStringPart)
                {
                    startOfStringPart = true;
                    result.Add(stringPart);
                    stringPart = new string(s[i], 1);
                }
                else
                {
                    stringPart += s[i];
                }
            }

            result.Add(stringPart);
            return result;
        }

        /// <summary>
        /// Convert the given string to CamelCasing (WhichLooksLikeThis).
        /// </summary>
        /// <param name="str">The string to convert.</param>
        /// <returns>The CamelCase representation of the given string.</returns>
        protected static string ToJSONCase(string str)
        {
            return char.ToLower(str[0]) + str.Substring(1);
        }

        /// <summary>
        /// Convert the given string to CamelCasing (WhichLooksLikeThis).
        /// </summary>
        /// <param name="str">The string to convert.</param>
        /// <returns>The CamelCase representation of the given string.</returns>
        protected static string ToCamelCase(string str)
        {
            return JoinWithCharacter(OneUpperRestLowerCase(SplitCamelCasing(str)), '\0');
        }

        /// <summary>
        /// Convert the given string to SnakeCasing (which_looks_like_this).
        /// </summary>
        /// <param name="str">The string to convert.</param>
        /// <returns>The SnakeCase representation of the given string.</returns>
        protected static string ToSnakeCase(string str)
        {
            return JoinWithCharacter(ToLowerCase(SplitCamelCasing(str)), '_');
        }

        /// <summary>
        /// Convert the given string to KebabCasing (which-looks-like-this).
        /// </summary>
        /// <param name="str">The string to convert.</param>
        /// <returns>The KebabCase representation of the given string.</returns>
        protected static string ToKebabCase(string str)
        {
            return JoinWithCharacter(ToLowerCase(SplitCamelCasing(str)), '-');
        }

        /// <summary>
        /// Convert the given string to PascalCasing (whichLooksLikeThis).
        /// </summary>
        /// <param name="str">The string to convert.</param>
        /// <returns>The PascalCase representation of the given string.</returns>
        protected static string ToPascalCase(string str)
        {
            var result = ToCamelCase(str);
            return char.ToLower(result[0]) + result.Substring(1);
        }

        /// <summary>
        /// Convert each string in the list to lowercase.
        /// </summary>
        /// <param name="strings">The list of strings to convert.</param>
        /// <returns>A list of the same strings as in the given list where every string is in lowercase.</returns>
        private static List<string> ToLowerCase(List<string> strings)
        {
            var result = new List<string>();
            foreach (var s in strings)
            {
                result.Add(s.ToLower());
            }
            return result;
        }

        /// <summary>
        /// Convert each string in the list to uppercase.
        /// </summary>
        /// <param name="strings">The list of strings to convert.</param>
        /// <returns>A list of the same strings as in the given list where every string is in uppercase.</returns>
        private static List<string> ToUpperCase(List<string> strings)
        {
            var result = new List<string>();
            foreach (var s in strings)
            {
                result.Add(s.ToUpper());
            }
            return result;
        }

        /// <summary>
        /// Convert each string in the list to lowercase except for the first letter which is in uppercase.
        /// </summary>
        /// <param name="strings">The list of strings to convert.</param>
        /// <returns>A list of the same strings as in the given list where every string is in lowercase except for its first letter which is in uppercase.</returns>
        private static List<string> OneUpperRestLowerCase(List<string> strings)
        {
            var result = new List<string>();
            foreach (var s in strings)
            {
                result.Add(char.ToUpper(s[0]) + s.Substring(1).ToLower());
            }
            return result;
        }

        /// <summary>
        /// Join all the strings in the given list and add the <paramref name="filler"/> character in between the string.
        /// </summary>
        /// <remarks>
        /// If the filler character is '\0', no filler is used. 
        /// </remarks>
        /// <param name="parts">The list of strings to join.</param>
        /// <param name="filler">The filler character to add in between the string parts.</param>
        /// <returns>A joined string of all the string parts with filler characters in between the parts.</returns>
        private static string JoinWithCharacter(List<string> parts, char filler)
        {
            var result = new StringBuilder();
            var start = true;
            foreach (var s in parts)
            {
                if (!start && filler != '\0')
                {
                    result.Append(filler);
                }

                result.Append(s);
                start = false;
            }

            return result.ToString();
        }
    }
}