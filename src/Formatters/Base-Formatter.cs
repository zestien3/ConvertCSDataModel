using System.Collections.Generic;
using System.IO;
using System.Reflection;
using System.Text;

namespace Z3
{
    internal abstract class BaseFormatter
    {
        public static readonly List<string> csStandardTypes = new() { "void", "bool", "sbyte", "byte", "char",
                                                                      "int16", "uint16", "int32", "uint32",
                                                                      "int64", "uint64", "single", "double",
                                                                      "string", "typedReference", "IntPtr", "UIntPtr",
                                                                      "object", "System.DateTime", "System.DateOnly" };

        protected TextWriter Output { get; }

        protected MetadataAssemblyInfo AssemblyInfo { get; }

        protected List<string> Usings { get; }

        protected int IndentLength { get; set; }

        /// <summary>
        /// The constructor of the abstract base class <see cref="BaseFormatter"/>.
        /// </summary>
        /// <param name="assemblyInfo">The assembly for which we create the output.</param>
        /// <param name="output">The output to which the type script code must be written.</param>
        protected BaseFormatter(MetadataAssemblyInfo assemblyInfo, TextWriter output)
        {
            Output = output;
            AssemblyInfo = assemblyInfo;
            Usings = [];
            IndentLength = 4;
        }

        /// <summary>
        /// Write the class representation formatted to the required programming language.
        /// </summary>
        /// <param name="classInfo"></param>
        public void FormatClass(MetadataClassInfo classInfo)
        {
            var assemblyName = Path.GetFileNameWithoutExtension(Assembly.GetEntryAssembly()!.ManifestModule.Name);
            WriteMultilineComment([
                $"This file is generated by {assemblyName} (https://github.com/zestien3/ConvertCSDataModel)",
                "Any changes made to this file will be lost once the file is re-generated.",
                $"The information in this file is collected from the .NET class {classInfo.FullName}"
            ], 0);
            WriteFileHeader(classInfo);

            foreach (var property in classInfo.Properties.Values)
            {
                var type = FormatType(property);
                if (!Usings.Contains(type))
                {
                    Usings.Add(type);
                    WriteUsing(property);
                }
            }

            if (Usings.Count > 0)
            {
                Output.WriteLine();
            }

            OpenNamespace(classInfo);

            WriteXmlDocumentation(classInfo.XmlComment, 0);
            OpenClass(classInfo);

            WriteConstructor(classInfo);

            foreach (var property in classInfo.Properties.Values)
            {
                if (!property.DontSerialize)
                {
                    Output.WriteLine();
                    WriteXmlDocumentation(property.XmlComment, 1);
                    WriteProperty(property);
                }
            }

            foreach (var field in classInfo.Fields.Values)
            {
                // Skip backing fields.
                if (!field.Name!.StartsWith('<') && !field.DontSerialize)
                {
                    Output.WriteLine();
                    WriteXmlDocumentation(field.XmlComment, 1);
                    WriteField(field);
                }
            }

            CloseClass(classInfo);

            CloseNamespace(classInfo);
        }

        protected abstract void WriteComment(string str, int indentLevel);
        protected abstract void WriteMultilineComment(IEnumerable<string> str, int indentLevel);
        protected abstract void WriteXmlDocumentation(XmlDocumentation? documentation, int indentLevel);
        protected abstract void WriteFileHeader(MetadataClassInfo classInfo);
        protected abstract void WriteUsing(IMemberInfo classInfo);
        protected abstract void OpenNamespace(MetadataClassInfo classInfo);
        protected abstract void OpenClass(MetadataClassInfo classInfo);
        protected abstract void WriteConstructor(MetadataClassInfo classInfo);
        protected abstract void WriteProperty(MetadataPropertyInfo classInfo);
        protected abstract void WriteField(MetadataFieldInfo classInfo);
        protected abstract void CloseClass(MetadataClassInfo classInfo);
        protected abstract void CloseNamespace(MetadataClassInfo classInfo);
        protected abstract string FormatType(IMemberInfo memberInfo);

        protected void WriteIndent(int level)
        {
            Output.Write(new string(' ', IndentLength * level));
        }

        /// <summary>
        /// Convert the CamelCased string into a list of small strings,
        /// each one starting from an uppercase letter.
        /// The casing itself is not changed.
        /// </summary>
        /// <remarks>
        /// Since the strings are pretty short, we will not use a StringBuilder.
        /// </remarks>
        /// <param name="s">The CamelCased string to split.</param>
        /// <returns>A list of string making up the CamelCased string</returns>
        protected static List<string> SplitCamelCasing(string s)
        {
            var result = new List<string>();
            var stringPart = new string(s[0], 1);
            bool startOfStringPart = true;
            for (int i = 1; i < s.Length; i++)
            {
                startOfStringPart = startOfStringPart && char.IsAsciiLetterUpper(s[i]);
                if (char.IsAsciiLetterUpper(s[i]) && !startOfStringPart)
                {
                    startOfStringPart = true;
                    result.Add(stringPart);
                    stringPart = new string(s[i], 1);
                }
                else
                {
                    stringPart += s[i];
                }
            }

            result.Add(stringPart);
            return result;
        }

        /// <summary>
        /// Convert the given string to CamelCasing (WhichLooksLikeThis).
        /// </summary>
        /// <param name="str">The string to convert.</param>
        /// <returns>The CamelCase representation of the given string.</returns>
        protected static string ToJSONCase(string str)
        {
            return char.ToLower(str[0]) + str.Substring(1);
        }

        /// <summary>
        /// Convert the given string to CamelCasing (WhichLooksLikeThis).
        /// </summary>
        /// <param name="str">The string to convert.</param>
        /// <returns>The CamelCase representation of the given string.</returns>
        protected static string ToCamelCase(string str)
        {
            return JoinWithCharacter(OneUpperRestLowerCase(SplitCamelCasing(str)), '\0');
        }

        /// <summary>
        /// Convert the given string to SnakeCasing (which_looks_like_this).
        /// </summary>
        /// <param name="str">The string to convert.</param>
        /// <returns>The SnakeCase representation of the given string.</returns>
        protected static string ToSnakeCase(string str)
        {
            return JoinWithCharacter(ToLowerCase(SplitCamelCasing(str)), '_');
        }

        /// <summary>
        /// Convert the given string to KebabCasing (which-looks-like-this).
        /// </summary>
        /// <param name="str">The string to convert.</param>
        /// <returns>The KebabCase representation of the given string.</returns>
        protected static string ToKebabCase(string str)
        {
            return JoinWithCharacter(ToLowerCase(SplitCamelCasing(str)), '-');
        }

        /// <summary>
        /// Convert the given string to PascalCasing (whichLooksLikeThis).
        /// </summary>
        /// <param name="str">The string to convert.</param>
        /// <returns>The PascalCase representation of the given string.</returns>
        protected static string ToPascalCase(string str)
        {
            var result = ToCamelCase(str);
            return char.ToLower(result[0]) + result.Substring(1);
        }

        /// <summary>
        /// Convert each string in the list to lowercase.
        /// </summary>
        /// <param name="strings">The list of strings to convert.</param>
        /// <returns>A list of the same strings as in the given list where every string is in lowercase.</returns>
        private static List<string> ToLowerCase(List<string> strings)
        {
            var result = new List<string>();
            foreach (var s in strings)
            {
                result.Add(s.ToLower());
            }
            return result;
        }

        /// <summary>
        /// Convert each string in the list to uppercase.
        /// </summary>
        /// <param name="strings">The list of strings to convert.</param>
        /// <returns>A list of the same strings as in the given list where every string is in uppercase.</returns>
        private static List<string> ToUpperCase(List<string> strings)
        {
            var result = new List<string>();
            foreach (var s in strings)
            {
                result.Add(s.ToUpper());
            }
            return result;
        }

        /// <summary>
        /// Convert each string in the list to lowercase except for the first letter which is in uppercase.
        /// </summary>
        /// <param name="strings">The list of strings to convert.</param>
        /// <returns>A list of the same strings as in the given list where every string is in lowercase except for its first letter which is in uppercase.</returns>
        private static List<string> OneUpperRestLowerCase(List<string> strings)
        {
            var result = new List<string>();
            foreach (var s in strings)
            {
                result.Add(char.ToUpper(s[0]) + s.Substring(1).ToLower());
            }
            return result;
        }

        /// <summary>
        /// Join all the strings in the given list and add the <paramref name="filler"/> character in between the string.
        /// </summary>
        /// <remarks>
        /// If the filler character is '\0', no filler is used. 
        /// </remarks>
        /// <param name="parts">The list of strings to join.</param>
        /// <param name="filler">The filler character to add in between the string parts.</param>
        /// <returns>A joined string of all the string parts with filler characters in between the parts.</returns>
        private static string JoinWithCharacter(List<string> parts, char filler)
        {
            var result = new StringBuilder();
            var start = true;
            foreach (var s in parts)
            {
                if (!start && filler != '\0')
                {
                    result.Append(filler);
                }

                result.Append(s);
                start = false;
            }

            return result.ToString();
        }
    }
}