using System.Collections.Generic;
using System.IO;
using System.Reflection;
using System.Text;

namespace Z3
{
    internal abstract class BaseFormatter
    {
        protected static readonly List<string> csStandardTypes = new() { "void", "bool", "sbyte", "byte", "char",
                                                                         "int16", "uint16", "int32", "uint32",
                                                                         "int64", "uint64", "single", "double",
                                                                         "string", "typedReference", "IntPtr", "UIntPtr",
                                                                         "object", "System.DateTime" };

        protected TextWriter Output { get; }

        /// <summary>
        /// The constructor of the abstract base class <see cref="BaseFormatter"/>.
        /// </summary>
        /// <param name="output">The output to which the type script code must be written.</param>
        protected BaseFormatter(TextWriter output)
        {
            Output = output;
        }

        /// <summary>
        /// Write the class representation formatted to the required programming language.
        /// </summary>
        /// <param name="classInfo"></param>
        public void FormatClass(MetadataClassInfo classInfo)
        {
            var assemblyName = Path.GetFileNameWithoutExtension(Assembly.GetEntryAssembly()!.ManifestModule.Name);
            WriteMultilineComment([
                $"This file is generated by {assemblyName}",
                "Any changes made to this file will be lost once the file is re-generated.",
                $"The information in this file is collected from the .NET class {classInfo.FullName}"
            ]);
            WriteFileHeader(classInfo);
            WriteUsings(classInfo);
            OpenNamespace(classInfo);
            OpenClass(classInfo);
            WriteProperties(classInfo);
            CloseClass(classInfo);
            CloseNamespace(classInfo);
        }

        protected abstract void WriteComment(string str);
        protected abstract void WriteMultilineComment(string[] str);
        protected abstract void WriteFileHeader(MetadataClassInfo classInfo);
        protected abstract void WriteUsings(MetadataClassInfo classInfo);
        protected abstract void OpenNamespace(MetadataClassInfo classInfo);
        protected abstract void OpenClass(MetadataClassInfo classInfo);
        protected abstract void WriteProperties(MetadataClassInfo classInfo);
        protected abstract void CloseClass(MetadataClassInfo classInfo);
        protected abstract void CloseNamespace(MetadataClassInfo classInfo);
        protected abstract string FormatType(string type);

        /// <summary>
        /// Checks is a type is a standard type. These are defined in the <see cref="csStandardTypes"/> list.
        /// </summary>
        /// <param name="type">The type to be checked.</param>
        /// <returns>True if it is a standard type, false otherwise.</returns>
        protected static bool IsStandardType(string type)
        {
            return csStandardTypes.Contains(type);
        }

        /// <summary>
        /// Convert the CamelCased string into a list of small strings,
        /// each one starting from an uppercase letter.
        /// The casing itself is not changed.
        /// </summary>
        /// <remarks>
        /// Since the strings are pretty short, we will not use a StringBuilder.
        /// </remarks>
        /// <param name="s">The CamelCased string to split.</param>
        /// <returns>A list of string making up the CamelCased string</returns>
        protected static List<string> SplitCamelCasing(string s)
        {
            var result = new List<string>();
            var stringPart = new string(s[0], 1);
            bool startOfString = true;
            for (int i = 1; i < s.Length; i++)
            {
                startOfString = startOfString && char.IsAsciiLetterUpper(s[i]);
                if (char.IsAsciiLetterUpper(s[i]) && !startOfString)
                {
                    startOfString = true;
                    result.Add(stringPart);
                    stringPart = new string(s[i], 1);
                }
                else
                {
                    stringPart += s[i];
                }
            }

            result.Add(stringPart);
            return result;
        }

        /// <summary>
        /// Convert the given string to CamelCasing (WhichLooksLikeThis).
        /// </summary>
        /// <param name="str">The string to convert.</param>
        /// <returns>The CamelCase representation of the given string.</returns>
        protected static string ToCamelCase(string str)
        {
            return JoinWithCharacter(OneUpperRestLowerCase(SplitCamelCasing(str)), '\0');
        }

        /// <summary>
        /// Convert the given string to SnakeCasing (which_looks_like_this).
        /// </summary>
        /// <param name="str">The string to convert.</param>
        /// <returns>The SnakeCase representation of the given string.</returns>
        protected static string ToSnakeCase(string str)
        {
            return JoinWithCharacter(ToLowerCase(SplitCamelCasing(str)), '_');
        }

        /// <summary>
        /// Convert the given string to KebabCasing (which-looks-like-this).
        /// </summary>
        /// <param name="str">The string to convert.</param>
        /// <returns>The KebabCase representation of the given string.</returns>
        protected static string ToKebabCase(string str)
        {
            return JoinWithCharacter(ToLowerCase(SplitCamelCasing(str)), '-');
        }

        /// <summary>
        /// Convert the given string to PascalCasing (whichLooksLikeThis).
        /// </summary>
        /// <param name="str">The string to convert.</param>
        /// <returns>The PascalCase representation of the given string.</returns>
        protected static string ToPascalCase(string str)
        {
            var result = ToCamelCase(str);
            return char.ToLower(result[0]) + result.Substring(1);
        }

        /// <summary>
        /// Convert each string in the list to lowercase.
        /// </summary>
        /// <param name="strings">The list of strings to convert.</param>
        /// <returns>A list of the same strings as in the given list where every string is in lowercase.</returns>
        private static List<string> ToLowerCase(List<string> strings)
        {
            var result = new List<string>();
            foreach (var s in strings)
            {
                result.Add(s.ToLower());
            }
            return result;
        }

        /// <summary>
        /// Convert each string in the list to uppercase.
        /// </summary>
        /// <param name="strings">The list of strings to convert.</param>
        /// <returns>A list of the same strings as in the given list where every string is in uppercase.</returns>
        private static List<string> ToUpperCase(List<string> strings)
        {
            var result = new List<string>();
            foreach (var s in strings)
            {
                result.Add(s.ToUpper());
            }
            return result;
        }

        /// <summary>
        /// Convert each string in the list to lowercase except for the first letter which is in uppercase.
        /// </summary>
        /// <param name="strings">The list of strings to convert.</param>
        /// <returns>A list of the same strings as in the given list where every string is in lowercase except for its first letter which is in uppercase.</returns>
        private static List<string> OneUpperRestLowerCase(List<string> strings)
        {
            var result = new List<string>();
            foreach (var s in strings)
            {
                result.Add(char.ToUpper(s[0]) + s.Substring(1).ToLower());
            }
            return result;
        }

        /// <summary>
        /// Join all the strings in the given list and add the <see cref="filler"/> character in between the string.
        /// </summary>
        /// <remarks>
        /// If the filler character is '\0', no filler is used. 
        /// </remarks>
        /// <param name="parts">The list of strings to join.</param>
        /// <param name="filler">The filler character to add in between the string parts.</param>
        /// <returns>A joined string of all the string parts with filler characters in between the parts.</returns>
        private static string JoinWithCharacter(List<string> parts, char filler)
        {
            var result = new StringBuilder();
            var start = true;
            foreach (var s in parts)
            {
                if (!start && filler != '\0')
                {
                    result.Append(filler);
                }

                result.Append(s);
                start = false;
            }

            return result.ToString();
        }
    }
}