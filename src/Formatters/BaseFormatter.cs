using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;

namespace Z3
{
    internal abstract class BaseFormatter
    {
        protected MetadataAssemblyInfo AssemblyInfo { get; }

        protected TextWriter Output { get; }

        protected BaseTypeConverter Converter { get; }

        protected List<string> ReferencedFiles { get; }

        protected int IndentLength { get; set; }

        /// <summary>
        /// The constructor of the abstract base class <see cref="BaseFormatter"/>.
        /// </summary>
        /// <param name="assemblyInfo">The assembly for which we create the output.</param>
        /// <param name="output">The output to which the type script code must be written.</param>
        /// <param name="converter">A clas to convert C# types to another programming language.</param>
        protected BaseFormatter(MetadataAssemblyInfo assemblyInfo, TextWriter output, BaseTypeConverter converter)
        {
            AssemblyInfo = assemblyInfo;
            Output = output;
            Converter = converter;

            ReferencedFiles = [];
            IndentLength = 4;
        }

        /// <summary>
        /// Write the class representation formatted to the required programming language.
        /// </summary>
        /// <remarks>
        /// There are a whole number of methods called to write a source file representing the given class.
        /// If you think that there is a class missing for a new programming language that you want to add,
        /// please feel free to add it.
        /// </remarks>
        /// <param name="classInfo">The class for which the definition is to be written.</param>
        public void FormatClass(MetadataClassInfo classInfo)
        {
            // Start by writing a mulitline comment stating that the file is autogenerated.
            var assemblyName = Path.GetFileNameWithoutExtension(Assembly.GetEntryAssembly()!.ManifestModule.Name);
            WriteMultilineComment([
                $"This file is generated by {assemblyName} (https://github.com/zestien3/ConvertCSDataModel)",
                "Any changes made to this file will be lost once the file is re-generated.",
                $"The information in this file is collected from the .NET class {classInfo.FullName}"
            ], 0);
            Output.WriteLine();

            // Write a fileheader if the target language requires one.
            WriteFileHeader(classInfo);

            // If we need to reference a file for externally defined classes, this can be done here.
            // The first one is for the baseclass of the class we are processing.
            // Interfaces are not yet supported. 
            if (null != classInfo.BaseType)
            {
                var baseType = classInfo.BaseType.Name!;
                if (!Converter.IsStandardType(baseType))
                {
                    baseType = Converter.ConvertType(baseType);
                    if (!ReferencedFiles.Contains(baseType))
                    {
                        ReferencedFiles.Add(baseType);
                        WriteFileReference(baseType, Converter.GetFileName(classInfo.BaseType.Name!), classInfo.SubFolder);
                    }
                }
            }

            // Here we write the references to the files for the defined properties.
            foreach (var property in classInfo.Properties.Values)
            {
                var type = Converter.ConvertType(property.Type!);
                if (!ReferencedFiles.Contains(type) && !Converter.IsStandardType(type))
                {
                    ReferencedFiles.Add(type);
                    WriteFileReference(type, Converter.GetFileName(property.Type!), property.DefiningClass.SubFolder);
                }
            }

            // Here we write the references to the files for the defined fields.
            foreach (var field in classInfo.Fields.Values)
            {
                var type = Converter.ConvertType(field.Type!);
                if (!ReferencedFiles.Contains(type) && !Converter.IsStandardType(type))
                {
                    ReferencedFiles.Add(type);
                    WriteFileReference(type, Converter.GetFileName(field.Type!), field.DefiningClass.SubFolder);
                }
            }

            if (ReferencedFiles.Count > 0)
            {
                Output.WriteLine();
            }

            // Here we can write the namespace the class is defined in.
            OpenNamespace(classInfo);

            // Now we write the XML documentation of the class
            // and the statement that starts the class definition.
            WriteXmlDocumentation(classInfo.XmlComment, 0);
            OpenClass(classInfo);

            // Here we can add a constructor if we want.
            WriteConstructor(classInfo);

            // Now we write the definitions of all properties that are to be serialized.
            foreach (var property in classInfo.Properties.Values)
            {
                Output.WriteLine();
                WriteXmlDocumentation(property.XmlComment, 1);
                WriteProperty(property);
            }

            bool firstLine = classInfo.IsEnum;

            // Followed by the definitions of all fields that are to be serialized.
            foreach (var field in classInfo.Fields.Values)
            {
                if (!firstLine)
                {
                    Output.WriteLine();
                }
                firstLine = false;
                WriteField(field);
            }

            // We now have the chance to close the class.
            CloseClass(classInfo);

            // We now have the chance to close the namespace.
            CloseNamespace(classInfo);
        }

        protected abstract void WriteComment(string str, int indentLevel);
        protected abstract void WriteMultilineComment(IEnumerable<string> str, int indentLevel);
        protected abstract void WriteXmlDocumentation(XmlDocumentation? documentation, int indentLevel);
        protected abstract void WriteFileHeader(MetadataClassInfo classInfo);
        protected abstract void WriteFileReference(string className, string fileName, string currentSubFolder);
        protected abstract void OpenNamespace(MetadataClassInfo classInfo);
        protected abstract void OpenClass(MetadataClassInfo classInfo);
        protected abstract void WriteConstructor(MetadataClassInfo classInfo);
        protected abstract void WriteProperty(MetadataPropertyInfo classInfo);
        protected abstract void WriteField(MetadataFieldInfo classInfo);
        protected abstract void CloseClass(MetadataClassInfo classInfo);
        protected abstract void CloseNamespace(MetadataClassInfo classInfo);

        protected void WriteIndent(int level)
        {
            Output.Write(new string(' ', IndentLength * level));
        }
    }
}