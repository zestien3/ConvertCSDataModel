using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using Zestien3;

namespace Z3
{
    internal abstract class BaseFormatter
    {
        protected MetadataAssemblyInfo AssemblyInfo { get; }

        protected MetadataClassInfo? ClassInfo { get; private set; } = null;

        protected UseInFrontendAttribute? UseInFrontend { get; private set; } = null;

        protected TextWriter Output { get; }

        protected BaseTypeConverter Converter { get; }

        protected List<string> ReferencedFiles { get; }

        protected int IndentSize { get; set; }

        /// <summary>
        /// The constructor of the abstract base class <see cref="BaseFormatter"/>.
        /// </summary>
        /// <param name="assemblyInfo">The assembly for which we create the output.</param>
        /// <param name="output">The output to which the type script code must be written.</param>
        /// <param name="converter">A clas to convert C# types to another programming language.</param>
        protected BaseFormatter(MetadataAssemblyInfo assemblyInfo, TextWriter output, BaseTypeConverter converter)
        {
            AssemblyInfo = assemblyInfo;
            Output = output;
            Converter = converter;

            ReferencedFiles = [];
            IndentSize = 4;
        }

        /// <summary>
        /// Write the class representation formatted to the required programming language.
        /// </summary>
        /// <remarks>
        /// There are a whole number of methods called to write a source file representing the given class.
        /// If you think that there is a class missing for a new programming language that you want to add,
        /// please feel free to add it.
        /// </remarks>
        /// <param name="classInfo">The class for which the definition is to be written.</param>
        /// <param name="useInFrontend">Info on the language we are translating the class to.</param>
        public void FormatClass(MetadataClassInfo classInfo, UseInFrontendAttribute useInFrontend)
        {
            ClassInfo = classInfo;
            UseInFrontend = useInFrontend;

            // Start by writing a mulitline comment stating that the file is autogenerated.
            var assemblyName = Path.GetFileNameWithoutExtension(Assembly.GetEntryAssembly()!.ManifestModule.Name);
            WriteMultilineComment([
                $"This file is generated by {assemblyName} (https://github.com/zestien3/ConvertCSDataModel)",
                "Any changes made to this file will be lost once the file is re-generated.",
                $"The information in this file is collected from the .NET class {ClassInfo.FullName}"
            ], 0);
            Output.WriteLine();

            // Write a fileheader if the target language requires one.
            WriteFileHeader();

            // If we need to reference a file for externally defined classes, this can be done here.
            // The first one is for the base-class of the class we are processing.
            // Interfaces are not yet supported. 
            if (null != ClassInfo.BaseType)
            {
                var baseType = BaseTypeConverter.StripToBareType(ClassInfo.BaseType.FullName!);
                if (!Converter.IsStandardType(baseType))
                {
                    if (!ReferencedFiles.Contains(baseType))
                    {
                        ReferencedFiles.Add(baseType);
                        WriteFileReference(baseType, Converter.GetFileNameForReference(ClassInfo.BaseType), UseInFrontend.SubFolder);
                    }
                }
            }

            // Here we write the references to the files for the defined properties.
            foreach (var property in classInfo.Properties.Values)
            {
                if (classInfo.FullName != property.Type!)
                {
                    var type = BaseTypeConverter.StripToBareType(property.Type!);
                    if (!ReferencedFiles.Contains(type) && !Converter.IsStandardType(type))
                    {
                        ReferencedFiles.Add(type);
                        if (property.DefiningClass!.UseInFrontend.ContainsKey(UseInFrontend.Language))
                        {
                            WriteFileReference(
                                type,
                                Converter.GetFileNameForReference(property.ImplementedClass!),
                                property.DefiningClass!.UseInFrontend[UseInFrontend.Language].SubFolder!);
                        }
                    }
                }
            }

            // Here we write the references to the files for the defined fields.
            foreach (var field in classInfo.Fields.Values)
            {
                if (classInfo.FullName != field.Type!)
                {
                    var type = BaseTypeConverter.StripToBareType(field.Type!);
                    if (!ReferencedFiles.Contains(type) && !Converter.IsStandardType(type))
                    {
                        ReferencedFiles.Add(type);
                        if (field.DefiningClass!.UseInFrontend.ContainsKey(UseInFrontend.Language))
                        {
                            WriteFileReference(
                                type,
                                Converter.GetFileNameForReference(field.ImplementedClass!),
                                field.DefiningClass!.UseInFrontend[UseInFrontend.Language].SubFolder!);
                        }
                    }
                }
            }

            if (ReferencedFiles.Count > 0)
            {
                Output.WriteLine();
            }

            // Here we can write the namespace the class is defined in.
            OpenNamespace();

            // Now we write the XML documentation of the class
            // and the statement that starts the class definition.
            WriteXmlDocumentation(ClassInfo.XmlComment, 0);

            OpenClass();

            // Here we can add a constructor if we want.
            WriteConstructor();

            // Now we write the definitions of all properties that are to be serialized.
            WriteProperties();

            // Followed by the definitions of all fields that are to be serialized.
            WriteFields();

            // We now have the chance to close the class.
            CloseClass();

            // We now have the chance to close the namespace.
            CloseNamespace();
        }

        protected abstract void WriteComment(string str, int indentLevel);
        protected abstract void WriteMultilineComment(IEnumerable<string> str, int indentLevel);
        protected abstract void WriteXmlDocumentation(XmlDocumentation? documentation, int indentLevel);
        protected abstract void WriteFileHeader();
        protected abstract void WriteFileReference(string className, string fileName, string currentSubFolder);
        protected abstract void OpenNamespace();
        protected abstract void OpenClass();
        protected abstract void WriteConstructor();
        protected abstract void WriteProperties();
        protected abstract void WriteFields();
        protected abstract void CloseClass();
        protected abstract void CloseNamespace();

        public void WriteIndent(int level)
        {
            Output.Write(new string(' ', IndentSize * level));
        }
    }
}